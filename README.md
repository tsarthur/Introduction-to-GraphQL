# Введение в GraphQL

В последнее время GraphQL приобрел большую популярность. И неудивительно, потому что это интересный подход к запросам данных. Поэтому его определенно стоит изучить. По своей сути GraphQL — это язык запросов со средой выполнения, которая может их выполнять. Хотя это альтернатива REST.

## Запросы

В REST у нас есть концепция множественных конечных точек. 
Чтобы получить ресурс, нам нужно выполнить запрос GET к этому конкретному URL-адресу.

![image](https://user-images.githubusercontent.com/105854514/173255469-1d001fff-1d98-4c89-9d34-59ca61aefb84.png)

С GraphQL мы подходим к вышеуказанной задаче по-другому. Во-первых, нам нужно определить схему.

**Схмема — описывает полный набор возможных данных (объекты, поля, отношения, все), к которым клиент может получить доступ.**

Мы определяем его в файле с расширением [.gql-] расширение. Наше приложение GraphQL должно определить набор возможных данных, которые могут запрашивать наши пользователи. Наш API проверяет входящие запросы и выполняет их по схеме.

Наиболее фундаментальной частью схемы является тип объекта. Он представляет, какие объекты наши пользователи могут получить из нашего сервиса и какие поля у них есть.

![image](https://user-images.githubusercontent.com/105854514/173255703-e51d1c21-004a-48a8-8638-6d9f9f5eb4ee.png)

Выше мы определяем простой тип объекта, который содержит три поля. Все они обязательные, и мы указываем это восклицательным знаком. Из-за этого каждый раз, когда наши пользователи запрашивают сообщения, каждое сообщение гарантированно содержит идентификатор, заголовок и абзац.

Вместо того, чтобы вызывать конкретную конечную точку, которая управляет сообщениями, у нас обычно есть одна конечная точка для управления **всеми** нашими ресурсами. Нам нужно отправить ему запрос, чтобы описать, какие данные нам нужны.

Во-первых, нам нужно определить наш запрос таким же образом, как мы создали наш тип объекта.

![image](https://user-images.githubusercontent.com/105854514/173255875-8909b5c3-c37f-419d-8dd1-d0e3ec4db013.png)

Как только это будет реализовано, мы можем выполнить запрос с указанным выше запросом.

![image](https://user-images.githubusercontent.com/105854514/173256342-47256acb-4714-4b7b-9dab-a52f816f12be.png)

Интересным моментом выше является то, что нам **не** нужно запрашивать все данные. В нашем запросе выше мы пропустили поле paragraphs. Благодаря исключению полей, которые нам не нужны, мы можем уменьшить объем данных, передаваемых между нашим интерфейсом и нашим сервером.

## Мутации и входы

Помимо извлечения данных, нам также нужен способ и заполнения. С REST мы бы отправили запрос POST на определенную конечную точку. С GraphQL мы используем ту же самую единую конечную точку, которую мы использовали для запроса данных.

Во-первых, нам нужно описать структуру данных, которые мы используем для создания сущности в нашей базе данных. Для этого мы определяем **input**.

![image](https://user-images.githubusercontent.com/105854514/173256548-af3da23e-7b94-4ab1-9203-3a8c511e92a6.png)

Получив входные данные, мы можем использовать их внутри нашей мутации. Он должен вернуть созданную сущность.

![image](https://user-images.githubusercontent.com/105854514/173256566-e064fd41-0ccb-4c4f-a00b-b4aae6472f17.png)

Как только мы определили и мутацию, и ввод, мы можем выполнить запрос, создающий сущность.

![image](https://user-images.githubusercontent.com/105854514/173256690-b643d975-409b-43a0-a124-8ed67195f44a.png)

Наш сервер ответит созданным постом!

![image](https://user-images.githubusercontent.com/105854514/173256919-7ee6774f-8931-4713-9d26-0529f99ba285.png)

## Реализация GraphQL с NestJS

Скоро!

